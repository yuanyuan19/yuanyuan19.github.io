<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo搭建个人博客</title>
    <link href="/2023/06/13/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/13/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-hexo搭建个人博客"><a href="#Github-hexo搭建个人博客" class="headerlink" title="Github + hexo搭建个人博客"></a>Github + hexo搭建个人博客</h1><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>搭建自己的个人博客 <a href="https://juejin.cn/post/7064515729298554887">Github + hexo 实现自己的个人博客、配置主题（超详细） - 掘金 (juejin.cn)</a></p><p>官方文档 <a href="https://hexo.io/zh-cn/docs/github-pages">在 GitHub Pages 上部署 Hexo | Hexo</a></p><p>主要看fluid文档(<a href="https://hexo.fluid-dev.com/docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">https://hexo.fluid-dev.com/docs/guide/#latex-数学公式</a>)</p><p><a href="https://markdown.com.cn/basic-syntax/htmls.html">Markdown 内嵌 HTML 标签 | Markdown 官方教程</a></p><p>要先安装<code>git</code>，<code>nodejs</code>和<code>Hexo</code></p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install  <span class="hljs-comment">#读取package.json并安装</span><br></code></pre></td></tr></table></figure><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">.<br>├── _config.yml <span class="hljs-comment">#网站的配置信息</span><br>├── package.json <span class="hljs-comment">#应用程序的信息</span><br>├── scaffolds <span class="hljs-comment">#模版文件夹，建文章时，Hexo 会根据 scaffold 来建立文件</span><br>├── <span class="hljs-built_in">source</span> <span class="hljs-comment">#用户资源</span><br>|   ├── _drafts<br>|   └── _posts<br>└── themes <span class="hljs-comment">#主题文件夹</span><br></code></pre></td></tr></table></figure><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;Write blog using markdown&quot;</span><br><span class="hljs-comment"># 或简写为</span><br>hexo n <span class="hljs-string">&quot;Write blog using markdown&quot;</span><br></code></pre></td></tr></table></figure><p>该命令会在 _post 目录下生成文件 write-blog-using-markdown.md。可以在文件开头设置标题，时间、标签，分类等，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">用</span> <span class="hljs-string">Markdown</span> <span class="hljs-string">写博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2018-08-13 09:22:18</span><br><span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">categories:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tutorial</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown</span><br></code></pre></td></tr></table></figure><p>接着这部分就是文章的正文，遵循 Markdown 格式。</p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br><span class="hljs-comment"># 或简写为</span><br>hexo g<br></code></pre></td></tr></table></figure><h3 id="启动网站"><a href="#启动网站" class="headerlink" title="启动网站"></a>启动网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br><span class="hljs-comment"># 或简写为</span><br>hexo s<br></code></pre></td></tr></table></figure><p>打开浏览器，在地址栏中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以看到自己的博客了。本地网站只是方便开发时预览效果，其他人无法通过互联网访问。</p><p><em>如果无法显示，可能是 4000 端口被占用了，可以使用如下命令指定端口</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo s -p 4444<br></code></pre></td></tr></table></figure><p><em>或者修改 node_modules&#x2F;hexo-server&#x2F;index.js 文件，修改默认端口</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">hexo.<span class="hljs-property">config</span>.<span class="hljs-property">server</span> = <span class="hljs-title function_">assign</span>(&#123;<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">4444</span>,<br>  <span class="hljs-attr">log</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">ip</span>: <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>  <span class="hljs-attr">compress</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">header</span>: <span class="hljs-literal">true</span><br>&#125;, hexo.<span class="hljs-property">config</span>.<span class="hljs-property">server</span>);<br></code></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>在 _config.yml 开启资源文件夹</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">post_asset_folder: true<br></code></pre></td></tr></table></figure><p>这样，在 _posts 目录下会生成一个与文章同名的文件夹。把需要插入到文章中的图片放到该文件夹中，并在写文章时通过如下标签引用即可。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;% asset_img &lt;图片名&gt; [图片标题] %&#125;<br></code></pre></td></tr></table></figure><h3 id="部署到-Github"><a href="#部署到-Github" class="headerlink" title="部署到 Github"></a>部署到 Github</h3><p>安装 hexo-deployer-git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改 _config.yml 配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">deploy:<br>  - type: git<br>    repo: https://github.com/yuanyuan19/yuanyuan19.github.io.git<br>    branch: gh-pages<br></code></pre></td></tr></table></figure><p>部署</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo deploy</span><br></code></pre></td></tr></table></figure><h3 id="使用-fluid-主题"><a href="#使用-fluid-主题" class="headerlink" title="使用 fluid 主题"></a>使用 fluid 主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure><p>主题将会被下载到 theme&#x2F;next 目录下。</p><p>在站点配置文件 _config.yml 更换主题：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#theme: landscape    # 注释掉这一行，换成下面</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>博客框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端三件套</title>
    <link href="/2023/06/13/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"/>
    <url>/2023/06/13/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/</url>
    
    <content type="html"><![CDATA[<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://zh.khanacademy.org/computing/computer-programming/programming/intro-to-programming/a/learning-programming-on-khan-academy">在可汗学院学习编程 (文章) | 编程简介 | 可汗学院 (khanacademy.org)</a></p><p><a href="https://www.runoob.com/css/css-link.html">CSS 链接(link) | 菜鸟教程 (runoob.com)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn">学习 Web 开发 | MDN (mozilla.org)</a></p><p>还有几本讲css,javascript和jquery的书，可以当字典用</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>你可以把<code>html</code>的标签看作<code>&lt;span&gt;</code>和<code>&lt;div&gt;</code>的拓展，事实上除了一些特别的标签，绝大多数的标签都只是有着不同的<code>css</code>样式而已。行内元素可以看作是<code>&lt;span&gt;</code>的拓展，块级元素可以看作是<code>&lt;div&gt;</code>的拓展。</p><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230512145434582.png" alt="image-20230512145434582"></p><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p><code>&lt;div&gt;</code>需要独占一行，不满足的时候就会另启一行从头开始。</p><h3 id="lt-h1-gt-lt-h6-gt-：头条"><a href="#lt-h1-gt-lt-h6-gt-：头条" class="headerlink" title="&lt;h1&gt;-&lt;h6&gt;：头条"></a><code>&lt;h1&gt;-&lt;h6&gt;</code>：头条</h3><h4>Australia</h4><p>The world's six largest country by total area.</p><h5>New South Wales</h5><p>A state on the east coast of Australia.</p><h6>Sydney</h6><p>The most populated city in Australia, but not the capital.</p><h3 id="lt-p-gt-：段落"><a href="#lt-p-gt-：段落" class="headerlink" title="&lt;p&gt;：段落"></a><code>&lt;p&gt;</code>：段落</h3><p><code>&lt;p&gt;</code>标签会把连续的空格只保留一个，删除所有的换行。使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin"><code>margin</code></a>属性去改变段落之间的间隙，<strong>不要</strong>在段落之间插入空的段落元素或者<code>&lt;br&gt;</code>元素。</p><p>She popularized the idea of machine-independent programming languages, which led to the development of COBOL, one of the first modern programming languages. She is credited with popularizing the term "debugging" for fixing computer glitches (inspired by an actual moth removed from the computer).</p><p><a href="http://en.wikipedia.org/wiki/Grace_Hopper">Biography from Wikipedia: Grace Hopper (CC-BY-SA)</a></p><h3 id="lt-pre-gt-：预定义格式文本"><a href="#lt-pre-gt-：预定义格式文本" class="headerlink" title="&lt;pre&gt;：预定义格式文本"></a><code>&lt;pre&gt;</code>：预定义格式文本</h3><p>在该元素中的文本通常按照原文件中的编排，以等宽字体<code>monospace</code>的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。</p><pre>      t          kl               L          TE        A       A          C    V           R A           DOU           LOU          REUSE          QUE TU          PORTES        ET QUI T'        ORNE O CI         VILISÉ        OTE-  TU VEUX         LA    BIEN        SI      RESPI                RER       - Apollinaire</pre><h3 id="lt-ul-gt-lt-ol-gt-lt-li-gt-：列表"><a href="#lt-ul-gt-lt-ol-gt-lt-li-gt-：列表" class="headerlink" title="&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;：列表"></a><code>&lt;ul&gt;,&lt;ol&gt;,&lt;li&gt;</code>：列表</h3><div><ul>    <li>Ada Lovelace</li>    <li>Grace Hopper</li>    <li>Tim Berners-Lee</li>    <li>Donald Knuth</li></ul><ol>    <li>1957: Fortran</li>    <li>1958: Lisp</li>    <li>1964: BASIC</li></ol></div><p><code>&lt;table&gt;</code>：表格</p><p>table 标签用于格式化表格数据。表标签必须包含将数据格式化为标题、行和列所需的所有子标签。 表格应以带有列名的标题行开头。 thead 元素开始标题区域，tr 元素创建一行，th 元素在行中创建单元格。一个表在表头之后可以包含任意数量的数据行。 tbody 标签开始正文（数据）区域，相同的 tr 标签创建一行，td 标签在每行中创建数据单元格。</p> <table>        <thead>            <tr>                <th>Photo</th>                <th>Name</th>                <th>Hobbies</th>            </tr>        </thead>        <tbody>            <tr>                <td><img src="https://www.kasandbox.org/programming-images/creatures/Hopper-Happy.png" height="30"></td>                <td>Hopper</td>                <td>Programming, hopping.</td>            </tr>            <tr>                <td><img src="https://www.kasandbox.org/programming-images/creatures/Winston.png" height="30"></td>                <td>Winston</td>                <td>Eating donuts, then regretting it after writing programs to realize how bad it is for him.</td>            </tr>            <tr>                <td><img src="https://www.kasandbox.org/programming-images/creatures/OhNoes.png" height="30"></td>                <td>Oh Noes Guy, the Error Buddy</td>                <td>Freaking out all the time.</td>            </tr>        </tbody>    </table><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><h3 id="lt-img-gt-：图片"><a href="#lt-img-gt-：图片" class="headerlink" title="&lt;img&gt;：图片"></a><code>&lt;img&gt;</code>：图片</h3><div>     <img src="https://www.kasandbox.org/programming-images/creatures/Hopper-Jumping.png" alt="A jumping Beaver" >    <img src="https://www.kasandbox.org/programming-images/creatures/Hopper-Cool.png" alt="A cool looking Beaver with sunglasses" width="80">    <img src="https://www.kasandbox.org/programming-images/creatures/Hopper-Happy.png" alt="A happy Beaver" width="50%"></div><h3 id="lt-a-gt-：链接"><a href="#lt-a-gt-：链接" class="headerlink" title="&lt;a&gt;：链接"></a><code>&lt;a&gt;</code>：链接</h3><p><code>&lt;a&gt; </code>标签既用于链接到其他网站，也用于链接到当前网页的部分内容。它有一个必需的属性：<code> href</code>。如果它应该转到一个新页面，那么这应该是一个以 <code>http://</code> 或<code> https://</code> 开头的 URL。如果它应该在当前页面内跳转，那么它应该以“#”开头，然后匹配要跳转到的标签的 id 属性（如“<code>#main</code>”）。  a 标签应包含浏览器应使其可点击的任何内容。这通常是文本，但也可以是图像或任何标签集合。</p><p>在新页面打开加上<code>target=&quot;_blank&quot;</code></p><div>    <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">canvas的链接</a>    <a href="#hh">到文章开头</a></div><h3 id="lt-br-gt-：换行"><a href="#lt-br-gt-：换行" class="headerlink" title="&lt;br&gt;：换行"></a><code>&lt;br&gt;</code>：换行</h3><h3 id="lt-em-gt-：斜体"><a href="#lt-em-gt-：斜体" class="headerlink" title="&lt;em&gt;：斜体"></a><code>&lt;em&gt;</code>：斜体</h3><h3 id="lt-strong-gt-：加粗"><a href="#lt-strong-gt-：加粗" class="headerlink" title="&lt;strong&gt;：加粗"></a><code>&lt;strong&gt;</code>：加粗</h3><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p><code>&lt;</code>是特殊字符，要转义。<code>&lt;</code>用<code>&amp;gt;</code>，<code>&gt;</code>用<code>&amp;lt;</code>。空格是<code>&amp;nbsp;</code>。</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230512154407093.png" alt="image-20230512154407093"></p><h2 id="插入样式表"><a href="#插入样式表" class="headerlink" title="插入样式表"></a>插入样式表</h2><p>插入样式表就是如何导入css样式</p><h3 id="行内样式表"><a href="#行内样式表" class="headerlink" title="行内样式表"></a>行内样式表</h3><p>当样式仅需要在一个元素上应用一次时使用，这不是一个好方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./mountain.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./mountain.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 300&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:300px;height:300px;background-color: blue&quot;</span>&gt;</span>qmy<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="内部样式表（一个页面）"><a href="#内部样式表（一个页面）" class="headerlink" title="内部样式表（一个页面）"></a>内部样式表（一个页面）</h3><p><code>&lt;style&gt;</code>放在body和head里都行。设置单个页面的css样式就用这个。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;head&gt; <br>  &lt;style&gt; <br>    hr &#123;<span class="hljs-attribute">color</span>:sienna;&#125;<br>    <span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;&#125; <br>    <span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;images/back40.gif&quot;</span>);&#125;  <br>  &lt;/style&gt; <br>&lt;/head&gt;<br></code></pre></td></tr></table></figure><h3 id="外部样式表（多个页面）"><a href="#外部样式表（多个页面）" class="headerlink" title="外部样式表（多个页面）"></a>外部样式表（多个页面）</h3><p>当样式需要应用于很多页面时，就用一个css文件存储样式，使用<code>&lt;link&gt;</code>在html中导入样式文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是一个样式表文件的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hr &#123;<span class="hljs-attribute">color</span>:sienna;&#125; <br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;&#125; <br><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/back40.gif&quot;</span>);&#125;<br></code></pre></td></tr></table></figure><h3 id="覆盖问题"><a href="#覆盖问题" class="headerlink" title="覆盖问题"></a>覆盖问题</h3><p>后来者覆盖前者</p><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413230303102.png" alt="image-20230413230303102"></p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413230748034.png" alt="image-20230413230748034"></p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器 #"></a>id选择器 <code>#</code></h3><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413231001488.png" alt="image-20230413231001488"></p><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413231026227.png" alt="image-20230413231026227"></p><h3 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器 ."></a>class选择器 <code>.</code></h3><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413231313775.png" alt="image-20230413231313775"></p><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413231405115.png" alt="image-20230413231405115"></p><h3 id="伪类选择器（用于变化）"><a href="#伪类选择器（用于变化）" class="headerlink" title="伪类选择器（用于变化）"></a>伪类选择器（用于变化）</h3><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413231800016.png" alt="image-20230413231800016"></p><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413232054668.png" alt="image-20230413232054668"><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413231932725.png" alt="image-20230413231932725"></p><p>鼠标放上去是hover状态，放大1.2倍</p><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413232238015.png" alt="image-20230413232238015"></p><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413232415532.png" alt="image-20230413232415532"></p><h4 id="父节点的第二个变蓝"><a href="#父节点的第二个变蓝" class="headerlink" title="父节点的第二个变蓝"></a>父节点的第二个变蓝</h4><p><img src="/assets/5_%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/image-20230413232757820.png" alt="image-20230413232757820"></p><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p><code>1em</code>：<code>1em</code>等于<code>font-size</code>，如果<code>font-size</code>使用<code>em</code>，则<code>1em</code>等于父元素的<code>font-size</code></p><p><code>70vh</code>：相对于视窗高度的70%</p><p><code>70%</code>：父元素的宽度的70%</p><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><p><code>font-weight</code>：设置字体粗细，<code>blod</code></p><p><code>font-family</code>：字体</p><p><code>font-size</code>：字体大小</p><p><code>font-style</code>：倾斜程度，<code>italic</code></p><p><code>text-align</code>：对齐方式</p><h3 id="盒子属性"><a href="#盒子属性" class="headerlink" title="盒子属性"></a>盒子属性</h3><p>一切皆是盒子</p><p><code>margin</code>：外边距</p><p><code>padding</code>：内边距，<code>1em</code></p><p><code>border</code>：边框，<code>4px dashed rgb(222,22,22)</code></p><h2 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h2><p><code>float:left</code>浮动的元素会脱离文档流，它会被拉到容器的一侧，然后由文档流包围它。多个浮动的盒子不会发生重叠，会紧靠在一起。</p><p><code>position:absolute</code>也是会脱离文档流，然后相对于最近的已定位的祖先元素进行定位，若没有，就相对于文档定位。记得设置<code>top,right</code>等属性</p><h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>HTML页面中的任意位置加上<code>&lt;script&gt;</code>标签即可。</p><ol><li><p>直接在<code>&lt;script&gt;&lt;/script&gt;</code>标签内编写JS代码。</p></li><li><p>将所需的代码通过<code>import</code>关键字引入到当前作用域。要使用<code>import</code>和<code>export</code>关键字必须用<code>&lt;script type=&quot;module&quot;&gt;</code>以ES6模块方式解析<code>js</code>代码。ES6的变量作用域是模块级别的，在其他模块中使用，要在<code>js</code>文件中用<code>export &#123;name,print&#125;</code>的方式导出变量或函数，然后用<code>import &#123; name, print &#125; from &#39;./example.js</code>导入变量。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123;name,print&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./example.js&quot;</span></span><br><span class="language-javascript">    <span class="hljs-title function_">print</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>./example.js</code>代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;acwing&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">export</span>&#123;<br>    name,print<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过<code>src</code>属性导入<code>js</code>文件。如果使用了<code>src</code>属性就不应该在标签内包含js代码，因为会被忽略。<code>src</code>可以是一个完整的URL，可以来自外域，解析这个资源时会发送<code>GET</code>请求以获取资源。比如导入<code>jquery</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>从上到下逐步执行，因此由于页面在解析到<code>&lt;body&gt;</code>标签时候开始渲染，把<code>&lt;script&gt;</code>放在<code>&lt;body&gt;</code>里，可以不用在完全加载javascript脚本后再渲染。</p><h2 id="变量与运算符"><a href="#变量与运算符" class="headerlink" title="变量与运算符"></a>变量与运算符</h2><h3 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h3><p><code>let</code>用来定义变量，<code>const</code>用来定义常量，给常量赋值会报错。</p><h3 id="变量类型常见用法"><a href="#变量类型常见用法" class="headerlink" title="变量类型常见用法"></a>变量类型常见用法</h3><p><code>number</code>：数值变量，例如1, 2.5</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x=<span class="hljs-number">1.</span>y=<span class="hljs-number">1.2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> x,<span class="hljs-keyword">typeof</span> y)<br><span class="hljs-keyword">let</span> t = <span class="hljs-number">1.234567</span>;<br><span class="hljs-keyword">let</span> s = t.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//保留后两位，s是string类型</span><br></code></pre></td></tr></table></figure><p><code>string</code>：字符串，例如”acwing”, ‘yxc’，单引号与双引号均可。字符串中的每个字符不像c++的可以修改，Javascript的字符串是只读的。如果想修改字符串只能重新构造。``内的是模板字符串，可以包含变量和表达式，并且可以跨行书写。<code>parseInt</code>和<code>parseFloat</code>可以把字符串解析为对应的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1=<span class="hljs-string">&quot;acwing&quot;</span>,s2=<span class="hljs-string">&#x27;qmy&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1[<span class="hljs-number">1</span>]); <span class="hljs-comment">//可读</span><br><br><span class="hljs-keyword">let</span> s3=s1/<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;x&#x27;</span>+s1.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3);<br><br><span class="hljs-keyword">let</span> s=<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>, I&#x27;m <span class="hljs-subst">$&#123;age/<span class="hljs-number">2</span>&#125;</span> years old.`</span>;<br><span class="hljs-keyword">const</span> message = <span class="hljs-string">`</span><br><span class="hljs-string">  This is a multi-line</span><br><span class="hljs-string">  string that spans</span><br><span class="hljs-string">  several lines.</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure><p><code>boolean</code>：布尔值，例如true, false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> flag=<span class="hljs-literal">false</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> flag);<br></code></pre></td></tr></table></figure><p><code>object</code>：对象类型，它是一组键对值，例如<code>&#123;name: &quot;yxc&quot;, age: 18&#125;</code>，它在<code>js</code>里用的非常的多。还有<code>[1, 2, 3]</code>，<code>null</code>，<code>dom</code>元素等，它们由<code>object</code>派生而来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> d = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;qmy&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;;<br><br>d[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;yxc&#x27;</span>;<br>d[<span class="hljs-string">&#x27;school&#x27;</span>] = <span class="hljs-string">&#x27;nuist&#x27;</span>;<br>d.<span class="hljs-property">school</span> = <span class="hljs-string">&#x27;nuist&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d[<span class="hljs-string">&#x27;name&#x27;</span>], d[<span class="hljs-string">&quot;age&quot;</span>]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d.<span class="hljs-property">name</span>, d.<span class="hljs-property">age</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<br><br><span class="hljs-comment">//数组对象</span><br><span class="hljs-keyword">const</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">//1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-string">&#x27;length&#x27;</span>]);<br><span class="hljs-comment">//dom对象</span><br><span class="hljs-keyword">let</span> d=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">typeof</span>(d));<br></code></pre></td></tr></table></figure><p><code>undefined</code>：未定义的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> t;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> t);<br><span class="hljs-keyword">let</span> t=<span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>和python一样，变量的类型是动态的。</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a,b]=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> &#123;name, age&#125; = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;;<br><br><br><span class="hljs-keyword">let</span> [a,b]=input.<span class="hljs-property">value</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>); <span class="hljs-comment">//input是&lt;textarea&gt;</span><br>a=<span class="hljs-built_in">parseInt</span>(a),b=<span class="hljs-built_in">parseInt</span>(b);<br>output.<span class="hljs-property">innerHTML</span>=a+b;<br><br></code></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p><code>**</code>表示乘方，等于与不等于用<code>===</code>和<code>!==</code></p><p>逻辑运算符和<code>c++</code>一样，<code>&amp;&amp;</code>表示与，<code>||</code>表示或，<code>!</code>表示非</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h3 id="获取输入的方式"><a href="#获取输入的方式" class="headerlink" title="获取输入的方式"></a>获取输入的方式</h3><p>从HTML与用户的交互中获得信息，例如通过<code>input</code>、<code>textarea</code>等标签获得输入，然后用<code>js</code>取得相应的<code>dom</code>元素，添加相应的监听器，通过通过<code>click</code>、<code>hover</code>等事件触发回调函数，处理<code>dom</code>元素的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>Run<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123;main&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./example.js&quot;</span>;</span><br><span class="language-javascript">    <span class="hljs-title function_">main</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>./example.js</code>代码如下，<code>querySelector</code>是原生<code>javascript</code>中的可以根据<code>css</code>选择器匹配<code>dom</code>元素的方法，详细见常见<code>api</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> input=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.input&quot;</span>);<br><span class="hljs-keyword">let</span> run =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><span class="hljs-keyword">let</span> output=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;pre&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>    run.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> s=input.<span class="hljs-property">value</span>;<br>        output.<span class="hljs-property">innerHTML</span>=s; <br>    &#125;);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input);<br>&#125;<br><br><span class="hljs-keyword">export</span>&#123;<br>    main<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>Ajax</code>与<code>WebSocket</code>从服务器端获取输入，详细见常见<code>api</code>。</p><p>标准输入，使用<code>process.stdin</code>，这个不重要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">&#x27;utf8&#x27;</span>);<br><br>process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;readable&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> chunk = process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">read</span>();<br>  <span class="hljs-keyword">if</span> (chunk !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 处理输入数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;输入的数据是：&#x27;</span> + chunk);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="输出方式"><a href="#输出方式" class="headerlink" title="输出方式"></a>输出方式</h3><p>调试用<code>console.log</code>，会将信息输出到浏览器控制台<br>改变当前页面的<code>HTML</code>与<code>CSS</code><br>通过<code>Ajax</code>与<code>WebSocket</code>将结果返回到服务器</p><h2 id="判断和循环"><a href="#判断和循环" class="headerlink" title="判断和循环"></a>判断和循环</h2><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> score = <span class="hljs-number">90</span>;<br><span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">85</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;C&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;D&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>JavaScript中的循环语句与C++中类似，也包含<code>for</code>、<code>while</code>、<code>do while</code>循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//0~9</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">//0~9</span><br><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    i++;<br>&#125;<br><span class="hljs-comment">//第一次无条件执行，0~9</span><br><span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    i++;<br>&#125;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="枚举数组"><a href="#枚举数组" class="headerlink" title="枚举数组"></a>枚举数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>&#125;<br><br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="枚举对象"><a href="#枚举对象" class="headerlink" title="枚举对象"></a>枚举对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&#x27;: &#x27;</span> + obj[key]);<br>&#125;<br><br><span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br>keys.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&#x27;: &#x27;</span> + obj[key]);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>以下为三种定义方式，如果没有定义返回值，返回<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数的<code>this</code>让人迷惑，对于不是箭头函数的情况，<code>function</code>中的<code>this</code>指针在被调用时动态确定，调用时谁直接指向函数的地址，<code>function</code>中的<code>this</code>就是谁的<code>this</code>，这篇知乎写的很好&#x2F;<a href="https://zhuanlan.zhihu.com/p/42145138">彻底搞懂JavaScript中的this指向问题 - 知乎 (zhihu.com)</a>。箭头函数的情况不太了解。</p><h2 id="object"><a href="#object" class="headerlink" title="object"></a><code>object</code></h2><p>对象因为很重要，单独拿出来详细写一遍，它由一组<code>key:value</code>构成。<code>value</code>可以是变量、数组、对象、函数等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;yxc&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">money</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">add_money</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">money</span> += x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性这样调用</p><p><code>person.name</code>,<code>person.add_money()</code><br><code>person[&quot;name&quot;]</code>,<code>person[&quot;add_money&quot;]()</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组由<code>object</code>派生而来，数组的下标不需要连续，可以是1,2,4,10…，数组的元素可以是变量，数组，对象，函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;yxc&quot;</span>];<br><br><span class="hljs-keyword">let</span> b = [<br>    <span class="hljs-number">1</span>,  <span class="hljs-comment">// 变量</span><br>    <span class="hljs-string">&quot;yxc&quot;</span>,  <span class="hljs-comment">// 变量</span><br>    [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>],  <span class="hljs-comment">// 数组</span><br>    <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 函数</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;,<br>    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;yxc&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;  <span class="hljs-comment">// 对象</span><br>];<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b[<span class="hljs-number">4</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);<br>b[<span class="hljs-number">0</span>]=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;嗨嗨嗨&quot;</span>)<br>&#125;<br>b[<span class="hljs-number">0</span>](); <span class="hljs-comment">//该函数的this指针指向该数组，详细看上面的解释</span><br></code></pre></td></tr></table></figure><p>属性<code>length</code>：返回数组长度，即最大下标+1。注意length是属性，不是函数，因此调用的时候不要加()<br>函数<code>push()</code>：向数组末尾添加元素<br>函数<code>pop()</code>：删除数组末尾的元素<br>函数<code>splice(a, b)</code>：删除从a开始的b个元素<br>函数<code>sort()</code>：将整个数组从小到大排序<br>自定义比较函数：<code>array.sort(cmp)</code>，函数cmp输入两个需要比较的元素，返回一个实数，负数表示第一个参数小于第二个参数，0表示相等，正数表示大于。</p><p>ellipse(x,y,w,h)绘制椭圆</p><p>react(x,y,w,h)绘制长方形</p><p>line(x1,y1,x2,y2)绘制线段</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的<code>this</code>指向类的实例。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;  <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;  <span class="hljs-comment">// 成员变量</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>();<br>&#125;<br><br>    <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sum</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>;  <span class="hljs-comment">// 成员变量可以在任意的成员函数中定义</span><br>    &#125;<br><br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 成员函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">toString</span>());<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, color</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(x, y); <span class="hljs-comment">// 这里的super表示父类的构造函数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>    &#125;<br>    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 调用父类的toString()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用<br>作为函数调用时，代表父类的构造函数，且只能用在子类的构造函数之中。作为对象时，指向父类的原型对象。<br>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字。<br>成员重名时，子类的成员会覆盖父类的成员。类似于C++中的多态。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在成员函数前添加<code>static</code>关键字即可。静态方法不会被类的实例继承，只能通过类来调用。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    &#125;<br><br><span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-title function_">print_class_name</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Point&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-title class_">Point</span>.<span class="hljs-title function_">print_class_name</span>();<br>p.<span class="hljs-title function_">print_class_name</span>();  <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>在ES6中，只能通过<code>class.propname</code>定义和访问。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>=<span class="hljs-title class_">Point</span>.<span class="hljs-property">cnt</span>;<br>        <span class="hljs-title class_">Point</span>.<span class="hljs-property">cnt</span>++;<br>&#125;<br><br><span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> + <span class="hljs-string">&#x27;)&#x27;</span>;<br>&#125;<br><br>&#125;<br><br><span class="hljs-title class_">Point</span>.<span class="hljs-property">cnt</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Point</span>.<span class="hljs-property">cnt</span>);<br></code></pre></td></tr></table></figure><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><p><code>addEventListener(event,function)</code>为元素绑定事件触发的函数。</p><p><code>event</code>可选的鼠标事件有单击<code>click</code>,双击<code>dblclick</code>,右击<code>contextmenu</code>,按下<code>mousedown</code>,抬起<code>mouseup</code>等，可以用<code>event.type</code>获得对应的鼠标事件，用<code>event.button</code>获得按下的按键，<code>event.clientX</code>获得事件发生的横坐标等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">type</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>event</code>可选的键盘事件有按下<code>keydown</code>，抬起<code>keyup</code>。<code>event.code</code>返回按的是哪个键。<code>event.altKey</code>、<code>event.ctrlKey</code>、<code>event.shiftKey</code>分别表示是否同时按下了alt、ctrl、shift键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keydown&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">type</span>,event.<span class="hljs-property">code</span>,event.<span class="hljs-property">altKey</span>,event.<span class="hljs-property">ctrlKey</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>表单事件：<code>focus</code>和<code>blur</code>两个<code>event</code>分别表示聚焦和失去焦点。<code>change</code>表示元素发生改变，只有在失去焦点的时候才会判断元素是否发生了改变。</p><p>窗口事件：需要绑定到全局对象<code>window</code>上。<code>resize</code>：当窗口大小放生变化，<code>scroll</code>：窗口的轴发生滚动的时候，<code>load</code>：当元素被加载完成时触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">type</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a><code>querySelector()</code></h3><p><code>querySelector()</code>接收<code>css</code>选择符，返回匹配的第一个后代元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> body=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>); <span class="hljs-comment">// 匹配&lt;body&gt;元素</span><br><span class="hljs-keyword">let</span> myDiv =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#myDiv&quot;</span>);<span class="hljs-comment">// 取得ID为&quot;myDiv&quot;的元素</span><br><span class="hljs-keyword">let</span> selected=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.selected&quot;</span>);<span class="hljs-comment">// 取得第一个类名为&quot;selected&quot;的元素</span><br><span class="hljs-keyword">let</span> img=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;img.button&quot;</span>);<span class="hljs-comment">// 取得类名为&quot;button&quot;的图片</span><br></code></pre></td></tr></table></figure><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p><code>setTimeout(func, delay)</code>：delay毫秒后，执行函数func()。</p><p><code>clearTimeout()</code>：关闭定时器，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> timeout_id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>js &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;, <span class="hljs-number">2000</span>);  <span class="hljs-comment">// 2秒后在控制台输出&quot;Hello World&quot;</span><br><span class="hljs-built_in">clearTimeout</span>(timeout_id);  <span class="hljs-comment">// 清除定时器</span><br></code></pre></td></tr></table></figure><p><code>setInterval(func, delay)</code>：每隔delay毫秒，执行一次函数func()，第一次在第delay毫秒后执行。</p><p><code>clearInterval()</code>：关闭周期执行的函数，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> interval_id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;, <span class="hljs-number">2000</span>);  <span class="hljs-comment">// 每隔2秒，输出一次&quot;Hello World&quot;</span><br><span class="hljs-built_in">clearInterval</span>(interval_id);  <span class="hljs-comment">// 清除周期执行的函数</span><br></code></pre></td></tr></table></figure><p><code>requestAnimationFrame(func)</code>：该函数会在下次浏览器渲染页面之前执行一次，通常会用递归写法。回调函数有一个参数，它会被赋值为函数执行的时间戳，单位为毫秒。例如下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params">timestamp</span>) =&gt; &#123;  <span class="hljs-comment">// 每帧将div的宽度增加1像素</span><br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">width</span>($(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">width</span>()+<span class="hljs-number">1</span>); <span class="hljs-comment">//有参数设置，无参数获得</span><br>    <span class="hljs-title function_">requestAnimationFrame</span>(step);<br>&#125;;<br><span class="hljs-title function_">requestAnimationFrame</span>(step);<br></code></pre></td></tr></table></figure><p>考虑到每次渲染的间隔时间不完全相同，所以有时候需要以时间作为单位去计算一些值，例如速度路程之类的，可以这样写。注意，如果把浏览器切到后台就不会继续渲染，因此也不会再执行回调函数，这时候切回浏览器，时间间隔会很大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> last_timestamp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">step</span> = (<span class="hljs-params">timestamp</span>) =&gt; &#123;  <span class="hljs-comment">// 每帧将div的宽度增加1像素</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(timestamp-last_timestamp);<br>    last_timestamp=timestamp;<br>    $(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">width</span>($(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">width</span>()+<span class="hljs-number">1</span>); <span class="hljs-comment">//有参数设置，无参数获得</span><br>    <span class="hljs-title function_">requestAnimationFrame</span>(step);<br>&#125;;<br><span class="hljs-title function_">requestAnimationFrame</span>(step);<br></code></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><code>localStorage</code></h3><p>数据存储方式：后端有云盘，mysql，redis，越往后数据越小访问越快；前端有<code>js</code>的变量，还有<code>localStorage</code>。</p><p>用<code>localStorage</code>保存的键值对储存在浏览器的本地存储空间中，它的作用域是与域名相关的。在浏览器的<code>application</code>里可以查看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;qmy&#x27;</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);  <span class="hljs-comment">//查不到就是null</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>);<br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>数据用键值对存比较方便，但是有的函数比如<code>WebSocket</code>的<code>send</code>就是只能传字符串，所以要有函数可以把键值对和字符串相互转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj =&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;yxc&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> str=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-keyword">let</span> new_obj=<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str,<span class="hljs-title function_">typeof</span>(str));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(new_obj,<span class="hljs-title function_">typeof</span>(new_obj));<br></code></pre></td></tr></table></figure><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p><code>Date.now()</code>返回一个整数，表示自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）起经过的毫秒数。</p><p><code>Date.parse(&quot;2022-04-15T15:30:00.000+08:00&quot;)</code>将日期字符串转换为时间戳，相对于协调世界时。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>Http</code>是基于请求-响应模式的协议，只能是<code>client</code>向<code>Server</code>主动发送请求，<code>Server</code>没法主动向<code>client</code>发消息。<code>WebSocket</code> 是一种基于消息的协议，它可以在<code>client</code>和<code>Server</code>之间建立一个全双工的连接，从而<code>Server</code>可以主动向<code>client</code>发信息。<code>ws</code>协议也有个加密版叫做<code>wss</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:8000/&quot;</span>); <span class="hljs-comment">//建立ws协议的连接。</span><br>socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-comment">//当连接建立时触发。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket 连接已打开&quot;</span>);<br>&#125;;<br>socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;     <span class="hljs-comment">//当从服务器端接收到消息时触发。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到消息：&quot;</span> + event.<span class="hljs-property">data</span>);<br>&#125;;<br>socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;Hello, WebSocket!&quot;</span>); <span class="hljs-comment">//向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。</span><br>socket.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;   <span class="hljs-comment">////当连接关闭后触发。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WebSocket 连接已关闭，状态码：&quot;</span> + event.<span class="hljs-property">code</span> + <span class="hljs-string">&quot;，原因：&quot;</span> + event.<span class="hljs-property">reason</span>);<br>&#125;; <br>socket.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">//关闭WebSocket连接</span><br></code></pre></td></tr></table></figure><h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;https://www.acwing.com&quot;</span>) <span class="hljs-comment">//在新标签栏中打开页面。</span><br>location.<span class="hljs-title function_">reload</span>() <span class="hljs-comment">//刷新页面。</span><br>location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;https://www.acwing.com&quot;</span> <span class="hljs-comment">//在当前标签栏中打开页面。</span><br></code></pre></td></tr></table></figure><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">Canvas 教程 - Web API 接口参考 | MDN (mozilla.org)</a></p><h3 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h3><p>是javascript的一个扩展库，当成语法糖就行。引入用第三中导入方式，可以是外域的url，也可以把jquery下载到本地，放到项目文件夹下用相对路径导入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery-3.7.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>$()</code>是一个函数，它可以接受 CSS 选择器、HTML 代码、DOM 元素、函数等参数，返回<code>jquery</code>对象。<code>javascript</code>变量可以包含<code>$</code>字符，把它作为<code>jquery</code>对象变量的前缀只是为了增强代码可读性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> $div=$(<span class="hljs-string">&#x27;.mydiv&#x27;</span>)  <span class="hljs-comment">//匹配所有满足条件的dom元素</span><br><br><span class="hljs-comment">//绑定与解绑</span><br>$div.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">type</span>,e.<span class="hljs-property">which</span>)&#125;);<br>$div.<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;&#125;)  <span class="hljs-comment">//快捷写法</span><br>$div.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;click&quot;</span>);<br><br><span class="hljs-comment">//存在多个相同类型的事件触发函数时，可以通过click.name来区分</span><br>$div.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click.name1&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">type</span>)&#125;);<br>$div.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;click.name1&quot;</span>);<br><br>$div.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;e.<span class="hljs-title function_">stopPropagation</span>();&#125;);<span class="hljs-comment">//阻止向上传递</span><br>$div.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;e.<span class="hljs-title function_">preventDefault</span>();&#125;);<span class="hljs-comment">//阻止当前事件触发</span><br>$div.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;);<span class="hljs-comment">//事件触发函数的return false等价于同时执行上面两个</span><br><br>$div.<span class="hljs-title function_">hide</span>(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//1000毫秒隐藏</span><br>$div.<span class="hljs-title function_">show</span>(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//1000毫秒展示</span><br><br><span class="hljs-comment">//操控dom元素</span><br><span class="hljs-keyword">let</span> $p =$(<span class="hljs-string">&quot;&lt;p id=\&quot;p1\&quot;&gt;Hello, world&lt;span&gt;!!&lt;/span&gt;&lt;/p&gt;&quot;</span>) ;<br>$div.<span class="hljs-title function_">append</span>($p); <span class="hljs-comment">//为$div里的所有dom元素添加$p</span><br>$div.<span class="hljs-title function_">remove</span>(); <span class="hljs-comment">//删除$div里的所有dom元素</span><br>$div.<span class="hljs-title function_">empty</span>();<span class="hljs-comment">//删掉所有匹配的dom元素的的后代</span><br><br><span class="hljs-comment">//操控元素的选择器</span><br>$div.<span class="hljs-title function_">addClass</span>(<span class="hljs-string">&#x27;my-div&#x27;</span>);<span class="hljs-comment">//添加类</span><br>$div.<span class="hljs-title function_">removeClass</span>(<span class="hljs-string">&#x27;my-div&#x27;</span>);<span class="hljs-comment">//删除类</span><br>$div.<span class="hljs-title function_">hasClass</span>(<span class="hljs-string">&#x27;my-div&#x27;</span>);<span class="hljs-comment">//判断类是否存在</span><br><br><span class="hljs-comment">//获得或修改元素的css样式、属性或内容，有值就是修改，没值就是获得</span><br>$div.<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background-color&#x27;</span>); <span class="hljs-comment">//获得css样式</span><br>$div.<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background-color&#x27;</span>,<span class="hljs-string">&#x27;orange&#x27;</span>); <span class="hljs-comment">//修改css样式</span><br>$div.<span class="hljs-title function_">css</span>(&#123;<br>    <span class="hljs-attr">width</span>:<span class="hljs-string">&quot;200px&quot;</span>,<br>    <span class="hljs-attr">height</span>:<span class="hljs-string">&quot;200px&quot;</span>,<br>    <span class="hljs-string">&quot;background-color&quot;</span>:<span class="hljs-string">&#x27;orange&#x27;</span>,<br>&#125;)<br>$div.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;yxc&#x27;</span>);  <span class="hljs-comment">//&lt;div yxc=&quot;18&quot;&gt;&lt;/div&gt; 获取yxc的值，结果是&#x27;18&#x27;</span><br>$div.<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&quot;ID&quot;</span>); <span class="hljs-comment">//把id的值改为ID</span><br>$div.<span class="hljs-title function_">text</span>();   <span class="hljs-comment">//无参数返回不带标签的文本，有参数就是设置文本</span><br>$div.<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>); <span class="hljs-comment">//无参数就是获取html标签，有参数就是设置文本内容</span><br>$input.<span class="hljs-title function_">val</span>(<span class="hljs-string">&#x27;hhh&#x27;</span>); <span class="hljs-comment">//无参数获取输入的值，有参数设置输入的值</span><br><br><span class="hljs-comment">//查找相邻节点</span><br>$div.<span class="hljs-title function_">parent</span>(); <span class="hljs-comment">//查找父节点</span><br>$div.<span class="hljs-title function_">parents</span>(<span class="hljs-string">&#x27;.div-1&#x27;</span>); <span class="hljs-comment">//祖先节点，用选择器筛选class为div-1的元素</span><br>$div.<span class="hljs-title function_">children</span>(<span class="hljs-string">&#x27;div&#x27;</span>); <span class="hljs-comment">//儿子节点，要满足是div标签</span><br>$div.<span class="hljs-title function_">find</span>(); <span class="hljs-comment">//子孙节点，注意不是childrens</span><br><br><span class="hljs-comment">//文档加载完毕后执行,隐式执行了$(document).ready(function()&#123;&#125;)</span><br>$(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;DOM is ready&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a><code>ajax</code></h3><p>jquery封装了原有的<code>ajax</code>，它用于发送异步请求。<code>GET</code> 请求将<code>data</code>参数附加在 URL 后面，以 <code>?</code> 开头，多个参数之间用 <code>&amp;</code> 分隔；<code>POST</code> 请求将<code>data</code>参数放在请求体中，不会在 URL 中显示。因此提交表单使用<code>POST</code>更隐私，获取资源的时候使用<code>GET</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>: url,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;GET&quot;</span>,  <span class="hljs-comment">//&#x27;POST&#x27;</span><br>    <span class="hljs-attr">data</span>: &#123;<br>    &#125;,<br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&quot;json&quot;</span>,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">resp</span>) &#123;<br>&#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用技术</category>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
      <tag>css</tag>
      
      <tag>javascript</tag>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx整理</title>
    <link href="/2023/06/13/nginx/"/>
    <url>/2023/06/13/nginx/</url>
    
    <content type="html"><![CDATA[<h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p>youtube <a href="https://www.youtube.com/watch?v=7VAI73roXaY">The NGINX Crash Course - YouTube</a></p><p>nginx是反向代理服务器</p><p><img src="/assets/nginx/image-20230509232737405.png" alt="image-20230509232737405"></p><p>使用用户较多，可以增加服务器数量来缓解服务器压力。通过反向代理服务器把请求发给实际的服务器</p><p>另一个是加密，使用https，意味着数据被加密</p><p>安装</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> update<br>sudo apt-<span class="hljs-built_in">get</span> install nginx<br></code></pre></td></tr></table></figure><p>Nginx的配置文件位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf。在Linux系统中，Nginx的配置文件通常位于此目录中。</p><p>Nginx的配置文件（nginx.conf）是Nginx服务器的主要配置文件，它定义了Nginx服务器的行为和性能。Nginx的配置文件包含多个块，每个块定义了不同的配置指令。以下是nginx.conf的一些常见配置指令：</p><ol><li>worker_processes：定义Nginx服务器使用的工作进程数。</li><li>error_log：定义Nginx服务器的错误日志文件路径。</li><li>access_log：定义Nginx服务器的访问日志文件路径。</li><li>server：定义Nginx服务器的虚拟主机。</li><li>location：定义Nginx服务器的URL位置和处理方式。</li><li>proxy_pass：定义Nginx服务器的反向代理。</li><li>root：定义Nginx服务器的默认文档根目录。</li></ol><p>通过编辑nginx.conf文件，您可以配置Nginx服务器的行为和性能，例如定义虚拟主机、反向代理、负载均衡等。</p><p>nginx启动服务，nginx -s stop停止服务</p><p>添加pages&#x2F;index.html</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello my friends<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改nginx.conf</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">http</span> &#123;<br><span class="hljs-keyword">server</span>&#123;<br>listen <span class="hljs-number">50</span>;<br>root <span class="hljs-operator">/</span>pages;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">events</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>然后nginx -s reload重新加载，就可以在50端口上看到index.html的内容了</p><p>添加.&#x2F;index.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>&#123;<br>        <span class="hljs-attribute">background-color</span>:pink;<br>        <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><p>html也做一些修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>my nginx project<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./index.css&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello my friends<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后按下ctrl+shift+r刷新缓存，就能看到网站这边是加载了的，但是css没正确显示，原因很简单，因为相应头的Content-Type错了</p><p><img src="/assets/nginx/image-20230510023122444.png" alt="image-20230510023122444"></p><p>添加types解决问题</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http &#123;<br><span class="hljs-keyword">types</span>&#123;<br><span class="hljs-type">text</span>/css     css;   #content-<span class="hljs-keyword">type</span>和拓展名<br><span class="hljs-type">text</span>/html    html;<br>&#125;<br><span class="hljs-keyword">server</span>&#123;<br><span class="hljs-keyword">listen</span> <span class="hljs-number">50</span>;<br>root /pages;<br>&#125;<br>&#125;<br><br>events &#123;&#125;<br></code></pre></td></tr></table></figure><p>记得nginx -s reload然后刷新缓存，就能看到css正确显示了</p><p>其实nginx.conf同名目录下有个<code>mime.types</code>，它是Nginx服务器中的一个配置文件，它定义了文件扩展名和MIME类型之间的映射关系。</p><p>把它include进来，然后也是能正确工作的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http &#123;<br><br><span class="hljs-keyword">include</span> mime.<span class="hljs-keyword">types</span>;<br><br><span class="hljs-keyword">server</span>&#123;<br><span class="hljs-keyword">listen</span> <span class="hljs-number">50</span>;<br>root /pages;<br>&#125;<br>&#125;<br><br>events &#123;&#125;<br></code></pre></td></tr></table></figure><p>location</p>]]></content>
    
    
    <categories>
      
      <category>实用技术</category>
      
      <category>nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux笔记整理</title>
    <link href="/2023/05/06/4_tmux/"/>
    <url>/2023/05/06/4_tmux/</url>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>如何在 Linux 上使用 tmux <a href="https://www.howtogeek.com/671422/how-to-use-tmux-on-linux-and-why-its-better-than-screen/">https://www.howtogeek.com/671422/how-to-use-tmux-on-linux-and-why-its-better-than-screen/</a></p><h3 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h3><p>在ubuntu上安装tmux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install tmux<br></code></pre></td></tr></table></figure><h3 id="常用命令速查"><a href="#常用命令速查" class="headerlink" title="常用命令速查"></a>常用命令速查</h3><ul><li><strong>Ctrl+B D</strong> — 从当前会话中分离。</li><li><strong>Ctrl+B X</strong> — 关闭窗格&#x2F;窗口&#x2F;会话。</li><li><strong>Ctrl+B %</strong> — 将窗口水平拆分为两个窗格。</li><li><strong>Ctrl+B “</strong> — 将窗口垂直拆分为两个窗格。</li><li><strong>Ctrl+B 箭头键</strong>（左、右、上、下）— 在窗格之间移动。</li><li><strong>Ctrl+B C</strong> — 创建一个新窗口。</li></ul><h3 id="启动tmux会话"><a href="#启动tmux会话" class="headerlink" title="启动tmux会话"></a>启动tmux会话</h3><p>输入<code>tmux</code>启动一个 tmux 会话，底部状态栏信息参考后面会细说。</p><p><img src="/assets/4_tmux/image-20230613145652694.png" alt="image-20230613145652694"></p><p>启动一个命名的<code>tmux</code>会话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="挂起-x2F-进入tmux会话"><a href="#挂起-x2F-进入tmux会话" class="headerlink" title="挂起&#x2F;进入tmux会话"></a>挂起&#x2F;进入tmux会话</h3><p>按下<code>Ctrl+B</code>来告诉<code>tmux</code>你要使用快捷键了。会话有两种状态：<code>attached</code>和<code>detached</code>，可以通过按<code>Ctrl+B</code>然后按<code>D</code>来进入<code>detached</code>状态，它将在后台继续运行。</p><p>列出活动的<code> tmux</code> 会话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux <span class="hljs-built_in">ls</span><br>0: 1 windows (created Sat Aug 27 20:54:58 2022)<br></code></pre></td></tr></table></figure><p>进入名称为0的<code>tmux</code>会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux attach -t 0<br></code></pre></td></tr></table></figure><p>所有<code> tmux</code> 命令也可以缩写，例如，您可以输入 <code>tmux a</code> ，它的作用与 <code>tmux attach</code>相同。</p><h3 id="使用窗口"><a href="#使用窗口" class="headerlink" title="使用窗口"></a>使用窗口</h3><p>按<code> Ctrl+B</code>，然后按 <code>C</code>来创建窗口</p><p>按<code>ctrl+B</code>，再按<code>N</code>显示下一个窗口</p><p>按<code>ctrl+B</code>，再按<code>P</code>显示上一个窗口</p><h4 id="状态栏信息"><a href="#状态栏信息" class="headerlink" title="状态栏信息"></a>状态栏信息</h4><p>状态栏右侧显示主机名、时间和日期。左侧显示会话相关信息：</p><p><code>[0]</code>：这是会话名称。默认情况下，它们从零开始编号。</p><p><code>0:bash*</code>：0 表示这是本次会话中的第一个窗口。在此会话中运行的唯一进程是<code>bash</code>。<code>*</code>表示正在查看的窗口。</p><p><img src="/assets/4_tmux/image-20230613145703229.png" alt="image-20230613145703229"></p><h3 id="使用窗格"><a href="#使用窗格" class="headerlink" title="使用窗格"></a>使用窗格</h3><p><code>Ctrl+B %</code>： 将窗口水平拆分为两个窗格。</p><p><code>Ctrl+B &quot; </code> ：将窗口垂直拆分为两个窗格。</p><p>窗格只会影响当前窗口</p><h3 id="关闭会话-x2F-窗口-x2F-窗格"><a href="#关闭会话-x2F-窗口-x2F-窗格" class="headerlink" title="关闭会话&#x2F;窗口&#x2F;窗格"></a>关闭会话&#x2F;窗口&#x2F;窗格</h3><p>如果想关闭当前的窗口，可以按<code>Ctrl+B</code>再按<code>X</code>。当关闭的窗口是此会话的最后一个窗口时，将终止当前的会话。如果有窗格，会先关闭当前的窗格。</p><h3 id="开启鼠标模式"><a href="#开启鼠标模式" class="headerlink" title="开启鼠标模式"></a>开启鼠标模式</h3><p>开启鼠标模式的方法为：先按<code>Ctrl+B</code>再按<code>:</code>，输入<code>set -g mouse on</code> 回车。</p>]]></content>
    
    
    <categories>
      
      <category>实用技术</category>
      
      <category>tmux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="/2023/05/06/3_docker/"/>
    <url>/2023/05/06/3_docker/</url>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>官方文档 <a href="https://docs.docker.com/get-started/02_our_app/">https://docs.docker.com/get-started/02_our_app/</a></p><p>菜鸟教程 <a href="https://www.runoob.com/docker/windows-docker-install.html">https://www.runoob.com/docker/windows-docker-install.html</a></p><h3 id="基础命令速查"><a href="#基础命令速查" class="headerlink" title="基础命令速查"></a>基础命令速查</h3><h4 id="镜像和容器的实用命令"><a href="#镜像和容器的实用命令" class="headerlink" title="镜像和容器的实用命令"></a>镜像和容器的实用命令</h4><p><code>docker pull ubuntu:20.04</code>：从云端拉取<code>ubuntu:20.04</code>的镜像，命令中的 <code>ubuntu</code>部分指定了包含该镜像的仓库，<code>:20.04</code>部分指定了标签，用于识别镜像的特定版本</p><p><code>docker run -p &lt;本机端口&gt;:&lt;容器端口&gt; --name &lt;容器名称&gt; -itd &lt;镜像名称&gt; </code>：创建并运行容器，其中<code>-d</code>参数使得容器在后台运行，<code>-p</code>指明了端口映射，如果使用<code>-t</code>参数，将不会在后台运行，而是进入交互式会话。</p><p>如果想进入在后台运行的容器，可以使用<code>docker attach &lt;容器名称&gt;</code>进入容器，如果用<code>exit</code>退出，容器会停止运行，先按<code>Ctrl+p</code>，再按<code>Ctrl+q</code>可以退出并让容器在后台运行。也可以用<code>docker exec -it &lt;name&gt; sh</code>在启动一个新的交互式 shell 会话，这样即使exit了容器也不会停止。</p><p><code>docker start &lt;容器名称&gt;</code>：启动容器</p><p><code>docker images</code>：列出本地所有镜像</p><p><code>docker ps -a</code>：查看本地的所有容器</p><p><code>docker build -t &lt;镜像名&gt; .</code>：利用<code>dockerfile</code>构建一个镜像，<code>-t</code>参数指定镜像名，<code>.</code>表示在当前目录下查找<code>dockerfile</code></p><p><code>docker commit &lt;container_name&gt; &lt;new_image_name&gt;</code>：将容器导出为镜像，保留容器所有历史文件和元数据</p><h4 id="在主机和容器之间传输文件"><a href="#在主机和容器之间传输文件" class="headerlink" title="在主机和容器之间传输文件"></a>在主机和容器之间传输文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">cp</span> &lt;SRC_PATH&gt; &lt;mycontainer&gt;:&lt;DEST_PATH&gt;<br>docker <span class="hljs-built_in">cp</span> &lt;mycontainer&gt;:&lt;SRC_PATH&gt; &lt;DEST_PATH&gt;<br></code></pre></td></tr></table></figure><p>其中，第一个命令将从主机的 <code>SRC_PATH</code> 复制文件或文件夹到运行中的 <code>mycontainer</code> 容器内的 <code>DEST_PATH</code> 目录，而第二个命令会将 <code>mycontainer</code> 容器内的 <code>SRC_PATH</code> 的文件或文件夹复制到主机上的 <code>DEST_PATH</code> 目录中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> blog_server:/blog ./1         <span class="hljs-comment">#复制blog文件夹到主机当前目录下的1文件夹</span><br>docker <span class="hljs-built_in">cp</span> blog_server:/blog/ ./1        <span class="hljs-comment">#复制blog文件夹下的内容到主机当前目录下的1文件夹</span><br></code></pre></td></tr></table></figure><h4 id="导出和导入tar文件"><a href="#导出和导入tar文件" class="headerlink" title="导出和导入tar文件"></a>导出和导入tar文件</h4><p>在 Docker 中，可以使用 <code>docker save</code> 和 <code>docker load</code> 命令来导出和导入镜像，使用 <code>docker export</code> 和 <code>docker import</code> 命令来导出和导入容器，使用<code>docker commit</code>将容器导出为镜像。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># save+save模式</span><br>docker commit &lt;container_name&gt; &lt;new_image_name&gt;：将容器导出为镜像，会保留容器的所有历史文件和元数据<br>docker save -o <span class="hljs-keyword">test</span>.tar blog_image         <span class="hljs-comment"># 导出镜像</span><br>docker load -i <span class="hljs-keyword">test</span>.tar                    <span class="hljs-comment"># 加载镜像</span><br><br><span class="hljs-comment"># export+import模式</span><br>docker <span class="hljs-keyword">export</span> -o <span class="hljs-keyword">test</span>.tar blog_container   <span class="hljs-comment"># 导出容器,会丢失所有元数据和历史记录，只保留最新的快照</span><br>docker import <span class="hljs-keyword">test</span>.tar blog_image:<span class="hljs-keyword">test</span>     <span class="hljs-comment"># 导入容器（得到的是镜像）</span><br></code></pre></td></tr></table></figure><p>这张截图的<code>blog_image:test</code>是用<code>import</code>导入的，首先是用<code>export</code>把<code>blog_container</code>容器导出为<code>test.tar</code>，然后用<code>test.tar</code>导入成镜像，这个镜像需要命名，这里命名为<code>blog_image:test</code></p><p><img src="/assets/3_docker/image-20230613145512297.png" alt="image-20230613145512297"></p><h4 id="将本地镜像上传到服务器"><a href="#将本地镜像上传到服务器" class="headerlink" title="将本地镜像上传到服务器"></a>将本地镜像上传到服务器</h4><p>将本地镜像上传到服务器，只需要上传<code>tar</code>文件即可，例如上传当前目录下的<code>blog.tar</code>到已经配置过别名的服务器，这个服务器应该安装了<code>docker</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">scp blog.tar aliyun:<span class="hljs-regexp">/home/</span>acs/   <span class="hljs-comment"># 上传到用户目录下</span><br></code></pre></td></tr></table></figure><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p><code>Docker</code> 实质上是在已经运行的<code>Linux</code>下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的<code>Linux</code>主机。也因此<code>Docker </code>必须部署在<code>Linux</code>内核的系统上。</p><p>如果其他系统想部署 <code>Docker</code> 就必须安装一个虚拟 <code>Linux </code>环境。以<code>windows</code>为例，在 <code>Windows</code> 系统上运行 <code>Docker</code> 实际上是在运行一个基于<code>Hyper-V</code>的虚拟机中运行<code>Docker</code>引擎。</p><blockquote><p><strong>windows安装</strong>：建议使用<code>Docker Desktop</code>，<a href="https://docs.docker.com/desktop/install/windows-install/">https://docs.docker.com/desktop/install/windows-install/</a></p><p><strong>linux安装</strong>：建议使用<code>Docker</code>引擎，<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p></blockquote><p>如果我在<code>Docker Desktop</code>里启动了一个容器，即使关闭窗口<code>Docker Desktop</code>也会在后台继续运行。在<code>linux</code>上，<code>docker</code>容器也是以后台进程的方式运行，即使关闭终端也不会停止容器，停止容器要使用<code>docker stop &lt;CONTAINER_ID&gt;</code>。</p><p>不能在 <code>Docker </code>容器或映像中运行<code> Docker</code>！！！</p><h3 id="在django项目中使用docker"><a href="#在django项目中使用docker" class="headerlink" title="在django项目中使用docker"></a>在<code>django</code>项目中使用docker</h3><h4 id="生成requirements-txt"><a href="#生成requirements-txt" class="headerlink" title="生成requirements.txt"></a>生成<code>requirements.txt</code></h4><p>以一个基于<code>django</code>框架的应用程序为例，<code>django</code>是基于<code>python</code>的框架，这个项目一直使用的是旧的<code>conda</code>环境，比较杂乱。所以首先我是在项目文件夹下新建一个<code>conda</code>环境。执行<code>conda create --prefix ./env python=3.10</code>在在当前目录下创建一个名为 <code>env</code> 的 <code>Conda</code> 环境，其中<code>--prefix</code>用于指定安装路径。激活这个环境需要指定路径<code>conda activate c:\Users\Matrix5952\Desktop\acapp\env</code>。</p><p>切换新环境后缺少相应的依赖包，用<code>pip</code>命令安装<code>django</code>包，注意一定要在新环境下！最后用<code>pip freeze &gt; requirements.txt</code>生成依赖库信息。</p><p><img src="/assets/3_docker/image-20230613145526076.png" alt="image-20230613145526076"></p><h4 id="创建Dockerfile并构建镜像"><a href="#创建Dockerfile并构建镜像" class="headerlink" title="创建Dockerfile并构建镜像"></a>创建<code>Dockerfile</code>并构建镜像</h4><p>在项目所在的目录下创建一个 <code>Dockerfile</code> 文件来储存 <code>Docker</code> 镜像构建时执行的指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用 Ubuntu 操作系统的最新版本，作为 Docker 镜像的基础。name:tag是镜像的命名规范，指定了它的名称和版本</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest<br><br><span class="hljs-comment"># 设置 Docker 容器内的工作目录为/acapp,在容器中执行命令时，默认的执行路径就是工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /acapp</span><br><span class="hljs-comment"># 将当前文件夹的所有内容拷贝到容器的工作目录</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . . </span><br><br><span class="hljs-comment">#使用 apt-get 命令安装 Python3 及其包管理器 pip</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y python3 python3-pip</span><br><br><span class="hljs-comment">#使用 pip3 命令安装工作目录下的 requirements.txt 文件中指定的所有依赖项。</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install -r requirements.txt</span><br></code></pre></td></tr></table></figure><p>然后执行<code>docker build -t acapp .</code>生成镜像，其中<code>-t</code>用于指定镜像的名称。生成的镜像会被储存在本地的镜像仓库中，可以使用<code>docker images</code>查看所有镜像。</p><h4 id="添加-dockerignore"><a href="#添加-dockerignore" class="headerlink" title="添加.dockerignore"></a>添加<code>.dockerignore</code></h4><p>因为执行了<code>COPY . . </code>，项目文件夹下的所有东西都被拷贝到了镜像里，包括<code>env</code>。我们知道<code>env</code>是<code>conda</code>虚拟环境，它在<code>windows</code>系统下创建的，那么直接拷贝到<code>linux</code>环境中是否仍可使用？答案是否，注释掉<code>RUN pip3 install -r requirements.txt</code>并生成镜像再创建相应的容器，在对应目录下执行<code>python3 manage.py runserver 0.0.0.0:8000</code>将告诉你没有<code>django</code>这个模块。</p><p>因此<code>env</code>并没有什么用，我们添加<code>.dockerignore</code>使它在构建时被忽略，文件内容如下，顺带着把<code>**/__pycache__</code>也忽略了。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">**/__pycache__<br><span class="hljs-keyword">env</span>/<br></code></pre></td></tr></table></figure><p>然后再生成镜像，忽略和不忽略分别构建出的镜像如下，可见size小了很多。</p><p><img src="/assets/3_docker/image-20230613145537138.png" alt="image-20230613145537138"></p><h4 id="利用镜像创建容器"><a href="#利用镜像创建容器" class="headerlink" title="利用镜像创建容器"></a>利用镜像创建容器</h4><p>执行<code>  docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name django_server -itd acapp</code>创建如下容器</p><p><img src="/assets/3_docker/image-20230613145543838.png" alt="image-20230613145543838"></p><p>执行<code>docker attach django_server</code>进入终端环境，接下来只要把它当成一个<code>linux</code>终端去使用就可以了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 根目录在/</span><br>root<span class="hljs-variable">@34fdff09cf31</span><span class="hljs-symbol">:/</span><span class="hljs-comment"># ls</span><br>acapp  boot  etc   lib    lib64   media  opt   root  sbin  sys  usr<br>bin    dev   home  lib32  libx32  mnt    <span class="hljs-built_in">proc</span>  run   srv   tmp  var<br><span class="hljs-comment"># 安装vim编辑器</span><br>root<span class="hljs-variable">@34fdff09cf31</span><span class="hljs-symbol">:/acapp/acapp</span> <span class="hljs-comment"># apt-get update </span><br>root<span class="hljs-variable">@34fdff09cf31</span><span class="hljs-symbol">:/acapp/acapp</span> <span class="hljs-comment"># apt-get install vim</span><br><span class="hljs-comment"># 这里略过了添加ALLOWED_HOSTS的过程</span><br><span class="hljs-comment"># 启动服务器</span><br>root<span class="hljs-variable">@34fdff09cf31</span><span class="hljs-symbol">:/acapp</span><span class="hljs-comment"># python3 manage.py runserver 0.0.0.0:8000</span><br></code></pre></td></tr></table></figure><p><code>8000:8000</code>前面的是本机端口，后面的是容器相应的端口，所以在主机的8000端口就可以访问到容器的应用程序。</p><h3 id="hexo框架搭建的博客使用docker"><a href="#hexo框架搭建的博客使用docker" class="headerlink" title="hexo框架搭建的博客使用docker"></a><code>hexo</code>框架搭建的博客使用docker</h3><h4 id="创建dockerfile"><a href="#创建dockerfile" class="headerlink" title="创建dockerfile"></a>创建<code>dockerfile</code></h4><p>回顾一下博客配置环境的过程，<code>Hexo</code>是基于<code>nodeJS</code>编写的，所以先安装了<code>nodeJs</code>和它的包管理器<code>npm</code>，然后执行<code>npm install -g hexo-cli</code>全局安装<code>Hexo</code>。接着执行以下代码来初始化博客项目，<code>npm install</code>会局部安装<code>dependences</code>里的所有依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init 文件夹名<br><span class="hljs-built_in">cd</span> 文件夹名<br>npm install<br></code></pre></td></tr></table></figure><p>因此<code>dockerfile</code>相应的内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基于ubuntu:latest镜像文件</span><br><span class="hljs-keyword">FROM</span> ubuntu:latest <br><br><span class="hljs-comment"># -y 自动确认，没加这个会报错，我猜测是执行这个命令的时候一直没确认所以卡住了</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y nodejs npm</span><br><br><span class="hljs-comment"># 全局安装 hexo</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm install -g hexo-cli</span><br><br><span class="hljs-comment"># 设置工作目录并把当前目录下所有文件拷贝到工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /blog</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br></code></pre></td></tr></table></figure><p>此时<code>hexo</code>环境就已经配置好了，文件夹下的文件也全部都拷贝过去了，现在思考一个问题。<code>package.json</code>里的依赖项有没有必要安装？事实上，现在创建出的镜像生成的容器已经可以运行博客应用程序了，这是因为<code>node_modules</code>里包括所有的依赖项，而它们也被拷贝到了镜像里，因此不用二次安装。</p><h4 id="添加-dockerignore-1"><a href="#添加-dockerignore-1" class="headerlink" title="添加.dockerignore"></a>添加<code>.dockerignore</code></h4><p>添加<code>.dockerignore</code>，它和<code>gitignore</code>一样用通配符匹配文件，这些文件在构建镜像时会被忽略。我直接把自带的<code>.gitignore</code>里的内容复制了过来，这里面包括但不限于<code>node_modules/</code>。然后用<code>docker build</code>创建镜像并<code>docker run</code>，结果正如所料<code>node_modules</code>没用被拷贝到工作目录下，因此执行<code>hexo s</code>时出现了问题。解决方案是执行<code>npm install</code>局部安装依赖再执行<code>hexo s</code>。所以在<code>dockerfile</code>里继续添加以下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 安装模块到项目 node_modules 目录下</span><br><span class="hljs-built_in">RUN</span> npm install<br></code></pre></td></tr></table></figure><p>但是要注意，<code>RUN</code>是在构建镜像时执行而非在创建容器时，因此新安装的模块也被放到了镜像内，所以上面两种方法创建出的镜像其实大小一样。</p><h3 id="acwing使用docker容器时的案例"><a href="#acwing使用docker容器时的案例" class="headerlink" title="acwing使用docker容器时的案例"></a><code>acwing</code>使用<code>docker</code>容器时的案例</h3><p>做的事情是，先把配置好的镜像上传到云服务器，然后用镜像创建<code>docker</code>容器，然后直接通过<code>ssh</code>登录。</p><p><code>AC Terminal</code>里有已经配置好环境的镜像，然后：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  <span class="hljs-comment"># 将镜像上传到自己租的云端服务器</span><br>ssh server_name  <span class="hljs-comment"># 登录自己的云端服务器</span><br>sudo usermod <span class="hljs-literal">-aG</span> docker <span class="hljs-variable">$USER</span> <span class="hljs-comment"># 将当前用户添加到docker用户组，再执行docker命令时不需要写sudo</span><br>docker load <span class="hljs-literal">-i</span> docker_lesson_1_0.tar  <span class="hljs-comment"># 将镜像加载到本地</span><br>docker run <span class="hljs-literal">-p</span> <span class="hljs-number">20000</span>:<span class="hljs-number">22</span> <span class="hljs-literal">--name</span> my_docker_server <span class="hljs-literal">-itd</span> docker_lesson:<span class="hljs-number">1.0</span>  <span class="hljs-comment"># 创建并运行docker_lesson:1.0镜像</span><br>docker attach my_docker_server  <span class="hljs-comment"># 进入创建的docker容器</span><br>passwd  <span class="hljs-comment"># 设置root密码</span><br></code></pre></td></tr></table></figure><p>去云平台控制台中修改安全组配置，放行端口20000，即可通过<code>ssh</code>登录自己的docker容器：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ssh root@xxx.xxx.xxx.xxx <span class="hljs-literal">-p</span> <span class="hljs-number">20000</span>  <span class="hljs-comment"># 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址</span><br></code></pre></td></tr></table></figure><p>创建工作账户<code>acs</code>，<code>ssh</code>登录并配置<code>docker</code>容器的别名和免密登录，具体可以参考<code>Linux</code>基础。</p><h4 id="增加容器的映射端口：80与443"><a href="#增加容器的映射端口：80与443" class="headerlink" title="增加容器的映射端口：80与443"></a>增加容器的映射端口：80与443</h4><p>在通过浏览器访问网站的时候，如果没指定端口号，网址以<code>http://</code>开头则浏览器会默认访问80端口，以<code>https://</code>开头浏览器会默认访问443端口。比如说我直接输入<code>8.130.116.50</code>，因为是基于<code>http</code>协议，所以访问的是80端口，如果在80端口启动了服务器，应该可以访问到。</p><p>这个方式是先把容器导出为镜像，然后用镜像重新生成一个映射到443和80端口的容器。先登录到<code>docker</code>容器把服务器关闭，再登录到云服务器，然后使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker commit django_server django_lesson:1.1 <span class="hljs-comment">#将django_server容器导出为django_lesson:1.1镜像</span><br>$ docker images <span class="hljs-comment">#列出本地镜像</span><br>REPOSITORY      TAG       IMAGE ID       CREATED          SIZE<br>django_lesson   1.1       3fae09fc0465   25 seconds ago   1.61GB<br>django_lesson   1.0       58e383d3fa92   17 months ago    1.5GB<br>$ docker stop django_server <span class="hljs-comment">#停止容器</span><br>$ docker <span class="hljs-built_in">rm</span> django_server <span class="hljs-comment">#删除容器</span><br>$ docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name django_server -itd django_lesson:1.1<br><span class="hljs-comment">#用镜像重新生成容器</span><br></code></pre></td></tr></table></figure><p><img src="/assets/3_docker/image-20230613145558122.png" alt="image-20230613145558122"></p><p>新的容器就创建好了。</p>]]></content>
    
    
    <categories>
      
      <category>实用技术</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习笔记</title>
    <link href="/2023/05/06/2_git/"/>
    <url>/2023/05/06/2_git/</url>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>廖雪峰的git教程 <a href="https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424">https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424</a></p><p>git官方文档 <a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h3 id="基础命令速查"><a href="#基础命令速查" class="headerlink" title="基础命令速查"></a>基础命令速查</h3><h4 id="初始化仓库和提交命令"><a href="#初始化仓库和提交命令" class="headerlink" title="初始化仓库和提交命令"></a>初始化仓库和提交命令</h4><p><code>git init</code>：将当前目录配置成<code>git</code>仓库，信息记录在隐藏的<code>.git</code>文件夹中，使用<code>ls -a</code>查看隐藏的文件夹。</p><p><code>git add &lt;file&gt;</code>：将<code>file</code>添加到暂存区</p><p><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</p><p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将暂存区的内容提交到当前分支</p><p><code>git status</code>：查看仓库状态</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p><code>git log</code>:查看提交日志</p><p><code>git reset --hard HEAD</code>:撤销对代码的修改并且将代码回滚到当前版本，<code>--hard</code>参数将暂存区与项目文件夹（工作区）中被追踪的文件的修改都撤销，但未追踪和<code>.gitignore</code>的文件不在它的管辖范围内，并删除该版本后的所有的提交。</p><p><code>git reset --hard HEAD~1</code> ：回到上一个版本</p><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p><code>git checkout HEAD~1</code>:切换到上一个版本（切换后<code>HEAD</code>处于<code>detached</code>）</p><p><code>git checkout master</code>:切换到master分支</p><p><code>git branch -v</code>:查看各个分支的最后一次提交</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p><code>git remote add origin git@xx.git</code> :<code>origin</code>是本地的远程仓库名称，<code>git@xx.git</code> 是远程仓库的地址</p><p><code>git push -u origin master</code> :将本地的 <code>master</code> 分支推送到远程仓库，<code>-u</code> 参数表示关联远程分支</p><p><code>git pull</code>：从远程仓库拉取最新代码</p><h3 id="配置密钥并推送到远程仓库"><a href="#配置密钥并推送到远程仓库" class="headerlink" title="配置密钥并推送到远程仓库"></a>配置密钥并推送到远程仓库</h3><p>执行<code>git init</code>初始化仓库，发现多了一个<code>.git</code>文件夹，所有与<code>git</code>有关的内容都储存在这个文件夹下</p><p>去<code>gitee</code>新建<code>acapp</code>仓库，在仓库首页有相关的命令行提示，可以参考。</p><p>如果没有配置用户名和邮箱，将无法使用<code>git commit</code>，配置用户名和邮箱的命令如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;献出心脏&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;10338170+devote_your_heart@user.noreply.gitee.com&quot;</span><br></code></pre></td></tr></table></figure><p>在你执行<code>git commit</code>时候会将你的用户名和邮箱与提交信息一起存储在本地仓库中，在推送和拉取远程仓库时会同时提交你的身份，以方便知道谁谁谁对代码做了什么。</p><p>执行<code>ssh-keygen</code>创建公私钥，执行<code>cat id_rsa.pub</code>查看公钥，然后把公钥粘贴到<code>gitee</code>的设置里。</p><p>执行以下命令以推送到远程仓库</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br>git commit -m <span class="hljs-string">&quot;first&quot;</span><br>git remote <span class="hljs-built_in">add</span> origin git@gitee.com:devote_your_heart/acapp.git<br>git push -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure><h4 id="建议添加-gitignore"><a href="#建议添加-gitignore" class="headerlink" title="建议添加.gitignore"></a>建议添加<code>.gitignore</code></h4><p>在<code>.gitignore</code>内的文件不会被追踪。使用通配符忽略文件或文件夹</p><p>比如<code>**/__pycache__</code>，<code>**</code>可以匹配任意数量的子目录，因此它可以匹配<code>/__pycache__</code>,<code>a/__pycache__</code>,<code>a/b/__pycache__</code>等文件夹</p><p>如果有子文件夹没有被<code>.gitignore</code>匹配，但在执行<code>git add .</code>时未能提交到暂存区，可能因为该子文件夹也存在<code>.git</code>文件夹，删除子文件夹下的<code>.git</code>文件夹再重新提交就行。</p>]]></content>
    
    
    <categories>
      
      <category>实用技术</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习笔记</title>
    <link href="/2023/05/06/1_linux%E6%95%B4%E7%90%86/"/>
    <url>/2023/05/06/1_linux%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="基础命令速查"><a href="#基础命令速查" class="headerlink" title="基础命令速查"></a>基础命令速查</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><strong>启用root用户账号</strong>：执行<code>sudo passwd root</code>设置<code>root</code>账户的密码。</p><p><strong>添加用户</strong>：使用<code>adduser acs</code>添加用户<code>acs</code>，按照提示输入密码。</p><p><strong>登录用户</strong>：<code>su root</code>以<code>root</code>用户身份登入，登录其他用户执行<code>su &lt;username&gt;</code></p><p><strong>退出用户</strong>：<code>exit</code>退出登录，当退出最后一个用户后会结束当前会话</p><p><strong>获取当前登录用户</strong>：<code>$USER</code> 是一个环境变量，用于获取当前登录用户的用户名，执行<code>echo $USER</code>打印当前用户名</p><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p><strong>添加<code>sudo</code>权限</strong>：普通用户执行一些命令需要<code>sudo</code>权限，使用<code>usermod -aG sudo acs</code>将用户添加到 <code>sudo</code> 组中，普通用户使用<code>sudo</code>权限会被要求输入当前用户密码。</p><p><strong><code>sudo: command not found</code>解决方案</strong>：<code>sudo</code> 是一个默认不安装在一些 Linux 发行版本中的命令行工具，遇到这种情况需要切换到<code>root</code>用户，然后安装<code>sudo</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">apt update<br>apt <span class="hljs-keyword">install</span> sudo<br></code></pre></td></tr></table></figure><p><strong>添加当前用户到<code>Docker</code>用户组</strong>：<code>sudo usermod -aG docker $USER</code>，这样可以允许该用户在后续操作中使用 <code>Docker </code>命令，而不需要通过 <code>sudo</code> 命令来执行命令。</p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>注意根目录的位置在<code>/</code></p><p><strong>rm删除命令</strong>：<code>rm</code> 命令可以删除文件和目录，语法：<code>rm [-fir] &lt;文件或目录&gt;</code>。<code>-f </code>表示强制删除，不需要对每个文件进行确认提示；<code>-r </code>表示递归删除目录下的所有文件，在删除文件夹的时候使用。例如强制删除某个文件夹可以执行<code>rm -rf &lt;path_to_directory&gt;</code></p><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><p>**<code>apt</code>和<code>apt-get</code>**：<code>apt</code> 是<code>apt-get</code>的优化版，二者都是用来管理 <code>Ubuntu </code>和 <code>Debian</code> 等 <code>Linux</code> 系统上的软件包的命令行工具。 </p><p>**<code>apt update</code>**：安装包前先执行<code>apt update</code>更新软件包列表，确保安装的是最新版本的包。</p><p><strong>安装包</strong>：<code>apt install &lt;package_name&gt;</code></p><blockquote><p><code>apt install -y &lt;package_name&gt; </code>：使用<code>apt</code>和<code>apt-get</code>都需要手动确认，通过在<code>install</code>后加上<code>-y</code>可以自动确认</p><p>在<code>dockerfile</code>里执行<code>apt install</code>一定要加上<code>-y</code>来自动确认！</p></blockquote><p><strong>卸载包</strong>：<code>apt remove &lt;package_name&gt;</code></p><h3 id="ssh登录远程服务器"><a href="#ssh登录远程服务器" class="headerlink" title="ssh登录远程服务器"></a>ssh登录远程服务器</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>ssh &lt;user&gt;@&lt;hostname&gt;</code>:远程登录服务器，<code>user</code>表示用户名，<code>hostname</code>表示<code>ip</code>地址或域名，默认登录端口号为22</p><p><code>ssh user@hostname -p 22</code>：登录到服务器特定端口</p><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>创建文件 <code>~/.ssh/config</code>，然后在文件中输入：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host server1<br>        HostName <span class="hljs-number">8.130</span>.<span class="hljs-number">116.50</span><br>        <span class="hljs-keyword">User</span> <span class="hljs-title">acs</span><br><br>Host django<br>        HostName <span class="hljs-number">8.130</span>.<span class="hljs-number">116.50</span><br>        <span class="hljs-keyword">User</span> <span class="hljs-title">acs</span><br>        Port <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>之后再登录<code>acs@8.130.116.50</code>时，可以直接用<code>ssh server1</code></p><h4 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h4><p>执行<code>ssh-keygen</code>在本地创建密钥，默认路径<code>.ssh</code>，一直按回车使用默认配置。执行完毕后后，<code>~/.ssh/</code>目录下会多出一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是公钥，另一个则是与之对应的私钥。</p><p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。例如，想免密登录<code>server1</code>服务器。则将公钥中的内容，复制到<code>server1</code>中的<code>~/.ssh/authorized_keys</code>文件夹内，也可以使用<code>ssh-copy-id myserver</code>一键添加公钥。</p><p>添加完登录就不需要输入密码了。</p><h3 id="scp传输文件"><a href="#scp传输文件" class="headerlink" title="scp传输文件"></a><code>scp</code>传输文件</h3><p><code>scp</code>是SSH协议下的一个文件传输工具，命令格式为<code>scp [options] &lt;source_path&gt; &lt;destination_path&gt;</code>，<code>[options]</code>表示可选参数，例如 <code>-r</code> 选项递归上传整个目录及其子目录的文件，<code>-P</code>指定远程 SSH 服务器的端口号，默认为 22。</p><p>例如<code>scp -r -P 20000 oj acs@8.130.116.50:/home/acs/</code>，将本地的<code>oj</code>文件夹上传到服务器的20000端口，由于已经配置过别名，命令等价于<code>scp -r oj django:/home/acs/</code>。</p>]]></content>
    
    
    <categories>
      
      <category>实用技术</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
