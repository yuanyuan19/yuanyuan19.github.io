## 编译器的概念

编译器是一组程序，可以将源程序翻译为可执行的程序。比如要盖一间木屋，首先得先造运输工具锤子斧头之类的工具，编译器就是这样的工具。

编译器是一组程序，可能运行在一种体系架构上。它生成的可执行程序，可能在另一种体系架构上。这种情况叫做交叉编译。

## GCC编译器

GCC是一组编译器套件，它支持 C、C++、Objective-C、Fortran、Ada 等多种编程语言，并且已经被移植到多种计算机体系架构上，如 x86,ARM,RISC-V 等

GCC并不单独提供，它被包含在GNU项目中，比如我们平时用的`gcc`被包含在`x86_64-linux-gnu-`中，同级的工具除了`gcc`还有`ar`,`g++`,`objcopy`,`objdump`,`ld`,`ar`等多种工具。

### GCC的编译，汇编，链接

以C语言为例，从 C 程序翻译成为可以在计算机上执行的机器语言程序的步骤：**编译，汇编，链接**。

**编译**：编译器完成 “预处理” 和 “编译”，“预处理” 指处理源文件中以 “#” 开头的预处理指令，譬如 #include、#define 等；“编译” 则针对预处理的结果进行一系列的词法分析、语法分析、语义分析，优化后生成汇编指令，存放在 .s 为后缀的汇编文件中

**汇编**：汇编器将汇编语言代码转换为机器语言，存放于.o文件中。.o是基于机器语言的文件，但还不是可执行的二进制文件。

**链接**：链接器将目标文件合并并和一些标准库（譬如 libc）文件链接，形成最终可执行的应用程序a.out。

![image-20231007190529188](assets/image-20231007190529188.png)



### GCC的不同版本

编译器本身也是可执行文件，可以自己从源码编译，也可以直接下载别人编译好的编译器。

我们平时用的`gcc`是一个软链接，它指向`gcc-11`，然后`gcc-11`又指向可执行文件`x86_64-linux-gnu-gcc-11`，由它生成的a.out只能在x86上运行。

利用`x86-64-linux-gnu-gcc-11`的源码，可以做一个生成的可执行文件可以在riscv64上运行的编译器`riscv64-unknown-elf-gcc`。用`riscv64-unknown-elf-gcc`生成的a.out，只能在riscv64架构的机器上运行。

ubuntu的官方仓库也提供了运行在x86上但生成在riscv上运行的可执行文件的编译器，执行`sudo apt autoremove gcc-riscv64-linux-gnu `安装。（不过我实际使用的时候出了点问题）。编译器是`riscv64-linux-gnu-gcc-11`

### GCC的命令

```shell
gcc hello.c					#编译C代码，生成可执行文件a.out
gcc -c hello.c -o hello.o	#生成目标文件
gcc -g -c hello.c			#生成带有调试信息的目标文件
gcc hello.c -v				#编译并显示详细的编译过程信息
```

下面这几个对应了GCC的执行步骤

```shell
gcc -E test.c -o test.i		# 预处理
gcc -S test.i -o test.s		# 编译
gcc -c test.s -o test.o		# 汇编	
gcc test.o -o a.out			# 链接
```

> | -E       | 只做预处理                     |
> | -------- | ------------------------------ |
> | 常用选项 | 含义                           |
> | -c       | 只编译不链接，生成文件.o       |
> | -S       | 生成汇编代码                   |
> | -o file  | 输出生成到指定文件中           |
> | -g       | 输出的文件中加入支持调试的信息 |
> | -v       | 输出整个翻译为可执行文件的过程 |
>

其他版本GCC的使用样例

```shell
riscv64-unknown-elf-gcc -march=rv32ima -mabi=ilp32 hello.c	#生成a.out
file a.out													#查看文件类型:risc-v上的可执行文件
qemu-riscv32-static ./a.out									#在模拟器上运行
```

## 文件

### 文件类型

常见文件类型如下：

`.c`：c源文件

`.cc/.cxx/.cpp`：c++源文件

`.i`：经过预处理的c源文件

`.s/.S`：汇编语言源文件，`.S`通常包含一些`#include`语句

`.h`：头文件

`.o`：目标文件

`a.out`：可执行文件

`os.elf` 和 `os.bin` ：

`os.elf` 是一种可执行文件，通常具有可执行代码、符号表、调试信息等。

`os.bin` 是一种纯二进制文件，只包含用于直接加载到内存的二进制数据。

在常见的情况下，`os.elf `文件是通过编译器和链接器生成的，它包含了完整的可执行程序的信息，可以在运行时被操作系统或硬件加载和执行。

而` os.bin `文件则是通过使用目标文件复制程序（如` objcopy`）从 `os.elf `文件中提取二进制数据生成的，它只包含原始的二进制数据，可以直接加载到指定的内存地址运行。

### 文件格式

可执行文件不是直接跑在硬件设备上的，中间隔了一层操作系统。要在操作系统上运行，可执行文件必须满足特定的格式，比如Windows的可执行文件格式是PE，Linux的就是ELF。

PE格式的文件包括以下几种类型：

| 文件类型                             | 说明                                    | 后缀          |
| ------------------------------------ | --------------------------------------- | ------------- |
| 可执行文件（Executable Files）       | Windows上的可执行文件                   | `.exe`,`.com` |
| 动态链接库（Dynamic Link Libraries） | Windows上的DLL文件                      | `.dll`        |
| 驱动程序文件（Device Drivers）       | Windows驱动程序文件，如内核模式驱动程序 | `.sys`        |

重点介绍ELF文件格式。

#### ELF

ELF格式的文件包括以下几种类型：

| ELF                           | 说明                                                         | 后缀    |
| ----------------------------- | ------------------------------------------------------------ | ------- |
| 目标文件（Object File）       | 包含了程序的二进制代码和数据，但它们还没有被链接为可执行文件 | `.o`    |
| 可执行文件（Executable File） | 可以直接执行的程序                                           | `a.out` |
| 共享库文件（Shared Library）  | 可以作为链接器的输入                                         | `.so`   |

ELF文件格式的结构如下：

![img](file:////home/yuanyuan/.config/QQ/nt_qq_5267431e0632a8e0f4adde49fdfc3552/nt_data/Pic/2023-09/Ori/89511b00105b15549e4e87c9502d999c.png)

#### 处理ELF文件的工具：Binutils

Binutils和GCC一样，被包含在GNU项目中，它包含多种命令行工具，用于处理二进制文件。

- `ar`：归档文件，将多个文件打包为大文件

- `as`：汇编器，被GCC调用，用于将汇编语言源代码文件转换成目标文件

   ```shell
   # 如果加上-v查看详细的过程，会发现gcc其实调用了as
  # 详细信息中显示调用了as -v --64 -o test.o test.s
  gcc -c test.s -o test.o	-v	
  ```
  
- `ld`：链接器，被GCC调用，用于将目标文件链接在一起，生成可执行文件或共享库

- `objcopy`：用于复制和转换目标文件格式等

  ```shell
  objcopy input.bin output.bin		# 复制文件
  objcopy -O binary os.elf os.bin 	# -O binary：输出.bin文件格式
  ```
  
- `objdump`：显示ELF文件的信息

   ```shell
   objdump -S hello.o					# 显示源代码和反汇编代码的交叉引用
   ```

- `readelf`：显示更多ELF格式文件的信息，直接vim查看是一堆乱码，得用专门工具看

   ```shell
   readelf -h hello.o					# h是header的缩写，查看文件头信息ELF Header
   readelf -S hello.o					# S是Section，查看Section Header Table
   readelf -SW hello.o					# W就是Wide的意思，这样查看比较舒服
   ```
