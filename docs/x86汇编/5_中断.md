# 中断

## 内中断

### 中断向量表

当cpu收到中断信息时，会先在栈中保存一些寄存器的值，然后跳转到中断处理程序执行。中断处理程序的入口地址存放于中断向量表中。中断信息带有中断类型码，CPU根据类型码计算得到存放入口地址的地方。

对于8086PC机，从0x00000 ~ 0x003FF共1K的字节，存放着中断向量表。因为一个中断源的入口地址占4个字节，所以可以存放256个中断源入口地址。高地址放段地址，低地址放偏移地址，即：
$$
IP=[N*4],CS=[N*4+2]
$$
其中$N$是中断类型码。

### 中断过程

当引发中断后，会依次执行：

从中断信息中取得中断类型码

标志寄存器的值入栈保存，设置TF=0，IF=0

CS，IP的值入栈，设置 $IP=[中断类型码*4]$ ，$CS=[中断类型码*4+2]$ 

### 中断处理程序

中断处理程序和子程序的过程很相似：

先保存用到的寄存器，然后处理中断，恢复用到的寄存器。

常规情况还要用`iret`指令返回，`iret`指令功能可以描述为`pop IP,pop CS,popf`

#### 处理0号中断的例子

下面除法的结果是1000H，但是在AL中放不下商，执行会发生0号中断

```masm
mov ax,1000H
mov bh,1
div bh
```

默认的0号中断处理程序是显示提示信息：Divide overflow，然后返回DOS系统

自己写一个处理0号中断的程序，要求发生中断时，显示overflow!。这段程序放在内存中的空间本应该由操作系统分配，但简单起见，就安装到0000:0200到0000:0300这段空间中。

程序分为3部分：用于将do0（中断处理程序）安装到0000:0200处的do0安装程序；设置中断向量表指向放好的do0；do0的内容

不能将overflow!放在安装程序中，因为安装程序执行完毕后会被系统释放，overflow!就随时可能被其他的信息覆盖。overflow!应该也被放到do0中

```masm
assume cs:code
code segment
start:	;do0安装程序
		mov ax,cs
		mov ds,ax
		mov si,offset do0						;设置ds:si指向源地址
		
		mov ax,0
		mov es,ax
		mov di,200H								;设置es:di指向目标位置
		
		mov cx,offset do0end-offset do0			;设置cx为传输长度
		cld										;设置传输方向为正
		rep movsb
		
		;设置中断向量表
		mov ax,0
		mov es,ax
		mov word ptr es:[0*4],200H
		mov word ptr es:[0*4+2],0
		
		mov ax,4c00H
		int 21H
		
do0:	;显示字符串overflow
		jmp short do0start
		db "overflow!"
do0start:
		mov ax,cs
		mov ds,ax
		mov si,202H
		mov ax,0b800H
		mov es,ax
		mov di,12*160+36*2
		
		mov cx,9
s:		mov al,[si]
		mov es:[di],al
		inc si
		add di,2
		loop s
		
		mov ax,4c00H
		int 21H
do0end:	nop

code ends
end start
```

### 单步中断

基本上CPU在执行完一条指令后，如果检测到标志寄存器TF的值为1，就会发生单步中断，中断类型码为1。

Debug就是利用这一点，Debug提供了单步中断的中断处理程序，功能是显示所有寄存器中的内容后等待用户输入。然后在使用T执行指令时，Debug将TF设置为1，则执行完下一条指令后就引发单步中断，执行单步中断的中断处理程序，将所有寄存器中的内容都显示在屏幕上，然后等待输入命令。

CPU在执行中断处理程序的时候没有中断，这是在此之前标志寄存器被入栈，并将TF=0

### int

用于引发中断过程，引发n号中断：

```
int n
```

### BLOS和DOS提供的中断程序

在系统板的ROM（只读存储器）中存放着一套程序，称为BLOS（基本输入输出系统）

BLOS主要包含几个部分：硬件系统的检测和初始化程序，外部中断和内部中断的中断例程，用于对硬件设备进行I/O操作的中断例程，其他中断例程

#### 安装过程

开机后，CPU加电，初始化CS:IP=FFFF:0000，然后FFFF:0000处存放的是一个跳转指令，执行后跳转到BLOS中的硬件系统检测和初始化程序。

BLOS的中断处理程序被固化在ROM中，初始化程序就是将BLOS提供的中断处理程序的入口地址登记到中断向量表中。

硬件系统检测和初始化完成后，调用`int 19H`进行操作系统的引导，将计算机交给操作系统控制。

DOS启动后，除了完成其他工作，还将它所提供的中断例程装入内存，并建立中断向量。

##### BLOS中断例程样例

`int 10H`是BLOS提供的中断例程，其中包含里多个和屏幕输出相关的子程序。

2号子程序用于设置光标位置：

```masm
mov ah,2				;置光标
mov bh,0				;第0页
mov dh,5				;行（0-24）
mov dl,12				;列（0-79）
int 10h
```

9号子程序用于在光标位置显示字符，要提供颜色信息和字符：

```
mov	ah,0				;调用9号子程序
mov al,'a'				;字符
mov bl,11001010B		;颜色属性
mov bh,0				;第0页
mov cx,3				;字符重复次数
int 10H
```

##### DOS中断例程样例

`int 21H`调用的中断处理程序是DOS提供的，包含了DOS提供给程序员在编程时调用的子程序。比如之前一直在使用的是`int 21H`中断例程的4CH号功能，即程序返回功能：

```masm
mov ah,4CH					;4CH号子程序
mov al,0					;返回值
int 21H
```

调用21H号中断处理程序的9号子程序，可以在光标位置显示字符串。

在屏幕的第5行12列显示字符串 “Welcome to masm!”：

```masm
assume cs:code
data segment
	db 'Welcome to masm!','$'	;遇到$字符串结束
data ends

code segment
start:	mov ah,2			;置光标
		mov bh,0			;第0页
		mov dh,5			;dh中放行号
		mov dl,12			;dl中放列号
		int 10H
		
		mov ax,data
		mov ds,ax
		mov dx,0			;ds:dx指向字符串的首地址data:0
		mov ah,9
		int 21H
		
		mov ax,4C00H
		int 21H
code ends
end start
```

## 端口

和总线相连的还有一些芯片，这些芯片里的一些寄存器，可以通过端口访问。

CPU通过端口地址来定位端口。

因为端口所在的芯片和CPU通过总线相连接，所以端口地址和内存地址一样也是通过地址总线来传输。

8086CPU最多定位64K个不同的端口，端口地址范围是0-65535

### in和out

对端口的读写只能使用`in`和`out`，比如从`60H`端口读如一个字节：

```
in al,60H
```

在`in`和`out`指令中，只能用AX和AL来存放从端口读入的数据或要发送到端口中的数据。访问8位端口时用AL，访问16位端口时用AX

```masm
;访问8位端口	0-255
in al,20H				;从20H端口读入一个字节
out 20H,al				;向20H端口写入一个字节

;访问16位端口	256-65535 
mov dx,3F8H				;将端口号3F8H送入DX
in al,dx				;从3f8h端口读入一个字节
out dx,al				;向3f8h端口写入一个字节
```

### 端口读写的例子

在PC机里有个CMOS RAM的芯片，这个芯片包含一个实时钟和一个有128个字节的RAM存储器。其中0-dH单元用于保存时间信息，其他大部分是系统配置信息，在系统启动的时候BLOS程序读写。

这个芯片有两个端口，70H和71H，70H端口存放要访问的CMOS RAM单元的地址，71H端口存放数据。比如读CMOS RAM的2号单元，要先把2送入端口70H，然后从71H读出2单元的内容。

这个芯片靠电池供电，所以关机后内部的实始终仍然可以正常工作。

从CMOS RAM的8号单元读出当前月份的BCD码：

```masm
mov al,8
out 70H,al

in al,71H
```

## 外中断

CPU通过端口和外部设备进行联系，外设的输入被送入到接口芯片的端口中，再通过总线读入CPU；CPU向外设输出的控制命令，也是先送入到相关芯片的端口当中，然后再由相关芯片根据命令对外设进行控制。

外中断可以分为可屏蔽中断和不可屏蔽中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。如果检测到可屏蔽中断信息且IF=1，则执行完当前指令后引发中断过程。如果IF=0，则不响应可屏蔽中断。几乎所有由外设引发的外中断都是可屏蔽中断。

